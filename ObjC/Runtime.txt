有两个版本的 Objective-C Runtime: modern (Objective-C 2.0) 和 legacy (Objective-C 1). 二者的最大不同是，前者的实例变量是 non-fragile 的：在 legacy runtime 中，更改类的实例变量布局 (layout) 后，必须重新编译该类的子类，而在 modern runtime 中则不必重新编译。此外，the modern runtime supports instance variable synthesis for declared properties.

Interacting with the Runtime
Objective-C 程序以 3 个不同的 levels 与 runtime 系统交互：Objective-C 源代码、NSObject 定义的方法、直接调用 runtime 函数。

//////////////////// Messaging ////////////////////
编译器把消息表达式 [receiver message] 转换成 objc_msgSend(receiver, selector, arg1, arg2, ...) 函数调用。objc_msgSend() 找到某个方法 aMethod 的实现时，还会向其传递两个隐藏的参数：接收消息的对象，以及方法的选择符。之所以说这两个参数是“隐藏”的，是因为定义 aMethod 的源代码中没有声明它们，它们只是在代码被编译时插入到了 aMethod 的实现中。仍可引用这两个隐藏参数：用 self 引用接收消息的对象，用 _cmd 引用方法自己的选择符。在方法的定义中，实际上也是通过这个隐藏的 self 参数访问接收消息的对象的实例变量的。
编译器为每个类和实例都构造了一个 class structure, 后者包含两个核心元素：
*) 一个指向父类的指针 self.superclass
*) A class dispatch table. It has entries that associate method selectors with the class-specific addresses of the methods they identify. (The implementation address of a method selector.)
对象被创建时，它会得到内存，其实例变量也会被初始化，其中就包含一个指向其 class structure 的指针 isa. 通过该指针可访问该对象所属的类、及所继承的类。
消息被发送给对象时，objc_msgSend() 函数会跟随该对象的 isa 指针到达其 class structure, 在其中的 dispatch table 中查找方法的选择符。若未找到，则顺着 self.superclass 指针在父类中找，一直到 NSObject; 若找到则调用。动态绑定就是这样实现的。
为了加速消息的处理，runtime system 使用了 cache 机制，缓存方法的选择符到方法的地址。每个类都有一个独立的 cache, 其中既可包含本类中定义的方法，亦可包含父类中的方法。Cache 是动态调整的。
-------------- Get a Method Address
可通过 NSObject 中定义的 - (IMP)methodForSelector:(SEL)aSelector 获得一个指向某方法 aMethod 的指针（也就是该方法的地址），并通过该指针像函数一样直接调用 aMethod. 注意必须小心地把该指针转换成适当的函数类型（函数指针）。
void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];
for (int i = 0; i < 1000; i++)
    setter(targetList[i], @selector(setFilled:), YES);
上面前两个参数分别是接收消息的对象 (self)，以及方法的选择符 (_cmd). 在 method 语法中这两个参数是隐藏的，但以 function 的形式调用 method 时，就必须显式地提供。
Comment: 同一个方法需要重复调用很多次时，使用 - methodForSelector: 可极大地减小 dynamic runtime system 发送消息的开销（因为不需要每次都查找 dispatch table 了）。注意 - methodForSelector: 不是 Objective-C 语言的特性，而是由 Cocoa runtime system 提供的。

//////////////////// Dynamic Method Resolution ////////////////////
动态地提供方法的实现。如 declared property @dynamic propertyName 告诉编译器，该属性关联的方法将会动态地提供。

//////////////////// Message Forwarding ////////////////////


Ref: Objective-C Runtime Programming Guide, Objective-C Runtime Reference.
